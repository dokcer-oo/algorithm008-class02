递归
递归需要满足的三个条件
一个问题的解可以分解为几个子问题的解（子问题就是数据规模更小的问题）。
这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样。
存在递归终止条件。
如何编写递归代码？
​	写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

​	如果一个问题 A 可以分解为若干子问题 B、C、D，可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。

​	递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。

递归代码可能出现的问题
堆栈溢出
重复计算
函数调用耗时多
空间复杂度高
分治算法
概念
​	分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

分治算法是一种处理问题的思想，递归是一种编程技巧。

分治算法一般都比较适合用递归来实现，分治算法的递归实现中文，每一层递归都会涉及到三个操作

分解：将原问题分解成一系列子问题。
解决：递归地求解个子问题，若子问题足够小，则直接求解。
合并：将子问题的结果合并成原问题结果。
分治算法能解决的问题，一般需要满足下面几个条件：

原问题与分解成的小问题具有相同的模式。
原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别。
具体分解终止条件，也就是时候，当问题足够小时，可以直接求解。
可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。
回溯算法
回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。